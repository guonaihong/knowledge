1、解释下什么是通道？

* 用法

```go
ch := make(chan bool)
ch <- true
<- ch
```

chan是golang的特色，主要是用于goroutine之间的通信，通过通信来共享内存，而不是通过共享内存来通信，减少并发的bug

2、互斥锁的概念，map线程不安全，怎么使用锁使得map安全？
对于并发安全的mpa，有三种实现方式

* map + sync.RWMutex
<https://github.com/antlabs/gstl/blob/master/rwmap/rwmap.go>

```go
type RWMap[K comparable, V any] struct {
 rw sync.RWMutex
 m  map[K]V
}
```

* 分区map+sync.Mutex
每个bucket是个由 `RWMap`组成，由多个RWMap组成一个slice
<https://github.com/antlabs/gstl/blob/master/cmap/cmap.go>

```go
type CMap[K constraints.Ordered, V any] struct {
 bucket   []Item[K, V]
 keySize  int
 isKeyStr bool
}
```

* sync.Map现有实现
sync.Map由两个map组成，只读map和写入map, 从形式上也类似于redis前面套个map，也有缓存穿透的处理
核心数据结构

```go
type Map struct {
 // 锁
 mu Mutex

 // 类似redis, 数据的子集
 read atomic.Pointer[readOnly]

 // 类似于mysql, 数据的超集
 dirty map[any]*entry

 // 数据穿透的次数
 misses int
}
```

比较难理解的一个核心点是，在`Store`函数里面，有时候只修改了read map，这是为啥？
因为 read和dirty的数据的value是共享的，持有同一份指针，只要修改了read，dirty的数据也会被修改

```go
func (m *Map) Load(key any) (value any, ok bool) {
 read := m.loadReadOnly()
 e, ok := read.m[key]
 if !ok && read.amended {
  m.mu.Lock()
  // Avoid reporting a spurious miss if m.dirty got promoted while we were
  // blocked on m.mu. (If further loads of the same key will not miss, it's
  // not worth copying the dirty map for this key.)
  read = m.loadReadOnly()
  e, ok = read.m[key]
  if !ok && read.amended {
   e, ok = m.dirty[key]
   // Regardless of whether the entry was present, record a miss: this key
   // will take the slow path until the dirty map is promoted to the read
   // map.
   m.missLocked()
  }
  m.mu.Unlock()
 }
 if !ok {
  return nil, false
 }
 return e.load()
}
```

3、介绍下waitgroup

* 用法

```go
var wg sync.WaitGroup
defer wg.Wait
wg.Add(1)
go func() {
  defer wg.Done()
  // do something
}()

```

* 原理

sync.WaitGroup 主要是基本计数和信号量实现的。  
计数为0时，唤醒wg.Wait()函数. 注意下这里面低4字节是存放等待的个数(这个问题在后面讲下)

```go
type WaitGroup struct {
 noCopy noCopy

 state atomic.Uint64 // high 32 bits are counter, low 32 bits are waiter count.
 sema  uint32
}
```

runtime_Semacquire 执行 P 操作：  
S = S - 1
判断  
    S < 0 阻塞
    S = 0 直接返回

当一个 Goroutine 调用 runtime_Semacquire 时，它会检查信号量的计数值。如果计数值大于 0 (count > 0)，它将减少该值并继续执行。如果计数值等于 0 (count == 0) 或更小，Goroutine 将被阻塞，直到其他 Goroutine 执行 runtime_Semrelease 操作，增加信号量的计数值，从而允许它继续执行。

runtime_Semrelease 执行 V 操作：  
S = S + 1
判断
如果 S > 0，则直接返回  
如果 S <=0， 释放阻塞队列中的第一个等待进程

当一个 Goroutine 调用 runtime_Semrelease 时，它会增加信号量的计数值。如果有其他 Goroutine 因为信号量的计数值等于 0 (count == 0) 或更小而被阻塞，增加计数值可能会唤醒其中一个等待的 Goroutine，使其能够继续执行 runtime_Semacquire 之后的代码。

* 聊下低4个字节的作用  
先看下这个例子，相比上面的例子，这里调用了两个`wg.Wait()`, 希望是所有的go程结果，在两个地方可以知道。
所以这里低4个字节是存放等待的个数`wg.Wait()`的个数

```go
func main() {
 var wg sync.WaitGroup
 const concurrency = 10000 // 假设我们有1万个goroutines

 // 启动100万个goroutines，每个都执行一个简单的任务
 for i := 0; i < concurrency; i++ {
  wg.Add(1) // 增加WaitGroup的计数器
  go func() {
   // 模拟一些工作
   doSomeWork()
   wg.Done() // 完成任务后减少计数器
  }()
 }

 // 等待所有goroutines完成
 go func() {
  wg.Wait()
  fmt.Println("1.所有goroutines都已完成。")
 }()
 wg.Wait()
 fmt.Println("2.所有goroutines都已完成。")
}

func doSomeWork() {
 time.Sleep(time.Second * 3)
 // 这里可以放置goroutines需要执行的工作
}
```

4、mysql索引问题：gender 在student表中是索引，sql select * from student where gender = 1;会走索引吗？

5、redis分布式锁实现

实现分布式锁，主要是实现lock和unlock

* lock
如果不存在则设置值，存在则不设置值。

```bash
SET mykey "随机值" NX PX 5000
```

* unlock
使用redis的del命令删除锁, 需要使用lua脚本实现

```go
var deleteScript = redis.NewScript(1, `
 local val = redis.call("GET", KEYS[1])
 if val == ARGV[1] then
  return redis.call("DEL", KEYS[1])
 elseif val == false then
  return -1
 else
  return 0
 end
`)
```

为什么value随机值?
是为了解决误删除的问题，假调A获得锁，这时候redis重启，数据丢了。B也获得锁，这时候A unlock，直接删除了这个key，B的访问就不是并发安全的。

下面是golang分布锁开源项目redsync，生成value值的代码，也可以用uuid实现，只是下面的方式省些内存

```go
func genValue() (string, error) {
 b := make([]byte, 16)
 _, err := rand.Read(b)
 if err != nil {
  return "", err
 }
 return base64.StdEncoding.EncodeToString(b), nil
}
```

* 续期
如果一个业务正常处理时间是1秒，少部分情况是3s，极端情况是30s，想实现Lock的时候加2s的超时时间，2s的时间到了，再加10s的超时时间，该如何实现？
redsync是通过以下两种方式实现，两个方式的唯一区别，是第一种方式容错性更高，比如redis集群重启，也可以正常处理。

```go
var touchWithSetNXScript = redis.NewScript(1, `
 if redis.call("GET", KEYS[1]) == ARGV[1] then
  return redis.call("PEXPIRE", KEYS[1], ARGV[2])
 elseif redis.call("SET", KEYS[1], ARGV[1], "PX", ARGV[2], "NX") then
  return 1
 else
  return 0
 end
`)

var touchScript = redis.NewScript(1, `
 if redis.call("GET", KEYS[1]) == ARGV[1] then
  return redis.call("PEXPIRE", KEYS[1], ARGV[2])
 else
  return 0
 end
`)
```

6、gorm的预加载实现
