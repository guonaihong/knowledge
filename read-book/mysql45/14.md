# MySQL知识点总结

## 1. `count(*)` 语句的实现方式

- **MyISAM引擎**：将表的总行数存储在磁盘上，执行 `count(*)` 时直接返回，效率高。
- **InnoDB引擎**：执行 `count(*)` 时需要逐行读取数据并计数。

## 2. InnoDB 引擎不存储行数的原因

- 由于事务的可重复读特性，InnoDB 需要通过多版本并发控制（MVCC）来确定每一行记录对当前会话的可见性。

## 3. `count(*)` 的性能优化

- MySQL 优化器会选择遍历最小的索引树来执行 `count(*)` 操作。

## 4. `show table status` 命令的局限性

- `TABLE_ROWS` 通过采样估算得到，误差可能达到40%到50%，不能直接使用。

## 5. 计数策略

- **使用缓存系统**：如 Redis，但可能存在数据丢失和计数不精确的问题。
- **在数据库中保存计数**：利用事务特性保证计数的准确性。

## 6. 不同 `count()` 用法的性能差异

- `count(字段)`：如果字段定义为 NOT NULL，则性能接近 `count(*)`；如果字段可为 NULL，则性能较差。
- `count(主键 id)` 和 `count(1)`：性能略低于 `count(*)`，但优于 `count(字段)`。

## 7. 事务隔离级别

- InnoDB 默认使用可重复读（RR）隔离级别，但有些公司可能使用读已提交（RC）隔离级别。

## 8. 思考题

- 在事务中，应该先插入操作记录还是先更新计数表？
