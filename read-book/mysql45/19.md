# MySQL实战45讲知识点总结

## 1. 查询性能优化
- 即使是查询单行数据，也可能遇到执行缓慢的情况。

## 2. 表被锁住的情况
- 表被锁可能因为多种原因，如MDL锁、flush操作或行锁。

### 2.1 等待MDL锁
- MDL（Metadata Lock）可能导致查询语句长时间等待。
- MySQL 5.7修改了MDL加锁策略，可以通过`sys.schema_table_lock_waits`表查询阻塞信息。

### 2.2 等待Table Flush
- `flush tables`命令可能导致查询语句等待。
- 复现步骤：一个会话执行长时间运行的查询，另一个会话尝试执行`flush tables`。

### 2.3 等待行锁
- 行锁可能导致查询语句在读取数据时被阻塞。
- MySQL 5.7可以通过`sys.innodb_lock_waits`表查询行锁信息。

## 3. 查询慢的原因
- 即使只扫描一行数据，查询也可能慢，原因可能包括：
  - 全表扫描没有使用索引。
  - 一致性读需要回滚日志（undo log）进行数据版本控制。

### 3.1 全表扫描
- 如果字段上没有索引，查询将执行全表扫描，导致性能下降。

### 3.2 一致性读与当前读
- `SELECT ... LOCK IN SHARE MODE`是当前读，可以快速获取最新数据。
- 普通`SELECT`查询是一致性读，可能需要检查多个版本的undo log。

## 4. 锁的加锁与释放
- 锁的加锁和释放与事务的开始和提交相关。
- 通过`KILL`命令可以断开持有锁的会话。

## 5. 特殊场景处理
- 字符串截断和索引匹配可能导致意外的查询性能问题。
- 函数操作可能影响查询性能，需要在server层做最终判断。
