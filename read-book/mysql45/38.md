# MySQL知识点总结

## InnoDB与Memory引擎的比较

### 数据组织方式
- **InnoDB引擎**：数据存储在主键索引上，称为索引组织表（Index Organized Table）。
- **Memory引擎**：数据和索引分开存放，采用堆组织表（Heap Organized Table）。

### 索引类型
- **InnoDB引擎**：使用B+树索引，数据有序存储。
- **Memory引擎**：默认使用hash索引，也支持B-Tree索引。

### 锁粒度
- **InnoDB引擎**：支持行锁，提供更好的并发性能。
- **Memory引擎**：只支持表锁，更新操作会阻塞其他读写操作。

### 数据持久性
- **InnoDB引擎**：数据存储在磁盘上，数据库重启后数据不丢失。
- **Memory引擎**：数据存储在内存中，数据库重启后数据会丢失。

### 适用场景
- **InnoDB引擎**：适用于生产环境，支持高并发和数据持久化。
- **Memory引擎**：适用于临时表，数据量不大且不需要持久化的场景。

## 内存表的特性和限制

1. **数据存储顺序**：内存表的数据按照写入顺序存放，而InnoDB表的数据有序存放。
2. **索引查找**：InnoDB表使用主键索引查询只需一次索引查找，普通索引查询需要两次；内存表所有索引查找次数相同。
3. **数据类型支持**：InnoDB支持变长数据类型，而内存表不支持Blob和Text字段，varchar实际按固定长度存储。

## 内存表在生产环境的问题

1. **锁粒度问题**：内存表的表锁会影响并发访问性能。
2. **数据持久性问题**：数据库重启会导致内存表数据丢失，影响主备同步和高可用架构。

## 内存临时表的优势

1. **并发性问题**：临时表不会被其他线程访问，无并发性问题。
2. **数据持久性**：临时表重启后数据清空，不涉及数据持久性问题。
3. **性能**：使用内存临时表可以提高复杂查询的性能，特别是当数据量可控时。


## 结论

- 普通内存表由于数据持久性和锁粒度问题，不适合在生产环境中作为常规数据表使用。
- InnoDB表在性能和数据安全方面表现更好，推荐在生产环境中使用。
- 内存临时表在特定场景下可以考虑使用，特别是数据量不大且需要快速读写时。