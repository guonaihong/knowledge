### go-zero并发控制

默认的并发控制，是基于chan实现的，来的请求向chan写数据，申请资格，离开的时候从chan读数据

* 配置文件

```yaml
MaxConns: 100
```

* 加载的中间件

```go
func MaxConnsHandler(n int) func(http.Handler) http.Handler {
 if n <= 0 {
  return func(next http.Handler) http.Handler {
   return next
  }
 }

 return func(next http.Handler) http.Handler {
  latch := syncx.NewLimit(n)

  return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
   if latch.TryBorrow() {
    defer func() {
     if err := latch.Return(); err != nil {
      logx.WithContext(r.Context()).Error(err)
     }
    }()

    next.ServeHTTP(w, r)
   } else {
    internal.Errorf(r, "concurrent connections over %d, rejected with code %d",
     n, http.StatusServiceUnavailable)
    w.WriteHeader(http.StatusServiceUnavailable)
   }
  })
 }
}
```

* 实现

```go
// ErrLimitReturn indicates that the more than borrowed elements were returned.
var ErrLimitReturn = errors.New("discarding limited token, resource pool is full, someone returned multiple times")

// Limit controls the concurrent requests.
type Limit struct {
 pool chan lang.PlaceholderType
}

// NewLimit creates a Limit that can borrow n elements from it concurrently.
func NewLimit(n int) Limit {
 return Limit{
  pool: make(chan lang.PlaceholderType, n),
 }
}

// Borrow borrows an element from Limit in blocking mode.
func (l Limit) Borrow() {
 l.pool <- lang.Placeholder
}

// Return returns the borrowed resource, returns error only if returned more than borrowed.
func (l Limit) Return() error {
 select {
 case <-l.pool:
  return nil
 default:
  return ErrLimitReturn
 }
}

// TryBorrow tries to borrow an element from Limit, in non-blocking mode.
// If success, true returned, false for otherwise.
func (l Limit) TryBorrow() bool {
 select {
 case l.pool <- lang.Placeholder:
  return true
 default:
  return false
 }
}
```

### 分析go-zero限流算法

* go-zero固定窗口限流器的实现

什么是基于固定窗口计数的限流式，比如一个时间片(假设1s)，最大允许的请求是100，超过这个值，直接报错。

在工程实现上一般要追求容错性和运维方面，一般会把实现放在redis。比如go-zero

go-zero的计算是保存在redis里面的，为了保证原子性，这块的逻辑是lua脚本实现的
<https://mp.weixin.qq.com/s/CTemkZ2aKPCPTuQiDJri0Q>

下面的lua脚本，主要干了2件事

* 通过lua的incrby原子计娄
* 如果第一次访问就加过期时间，主要是为了清空这个窗口
* 返回访问数是否到达限制(1 未到达限制， 2 已达到限制， 0 超出限制)

```lua
local limit = tonumber(ARGV[1])
local window = tonumber(ARGV[2])
local current = redis.call("INCRBY", KEYS[1], 1)
if current == 1 then
    redis.call("expire", KEYS[1], window)
end
if current < limit then
    return 1
elseif current == limit then
    return 2
else
    return 0
end
```

* golang 调用的地方

```go
func (h *PeriodLimit) TakeCtx(ctx context.Context, key string) (int, error) {
 resp, err := h.limitStore.ScriptRunCtx(ctx, periodScript, []string{h.keyPrefix + key}, []string{
  strconv.Itoa(h.quota),
  strconv.Itoa(h.calcExpireSeconds()),
 })
 if err != nil {
  return Unknown, err
 }

 code, ok := resp.(int64)
 if !ok {
  return Unknown, ErrUnknownCode
 }

 switch code {
 case internalOverQuota:
  return OverQuota, nil
 case internalAllowed:
  return Allowed, nil
 case internalHitQuota:
  return HitQuota, nil
 default:
  return Unknown, ErrUnknownCode
 }
}
```

* 基于固定窗口的缺点

假设每个窗口的时间是1s，最大请求数是100, 第一个窗口后0.5s访问了 100, 第二个窗口的前0.5s访问了100，那这段时间实际访问了200，达到限流数的2倍。
