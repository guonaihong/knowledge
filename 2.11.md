### go-zero并发控制

默认的并发控制，是基于chan实现的，来的请求向chan写数据，申请资格，离开的时候从chan读数据

* 配置文件

```yaml
MaxConns: 100
```

* 加载的中间件

```go
func MaxConnsHandler(n int) func(http.Handler) http.Handler {
 if n <= 0 {
  return func(next http.Handler) http.Handler {
   return next
  }
 }

 return func(next http.Handler) http.Handler {
  latch := syncx.NewLimit(n)

  return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
   if latch.TryBorrow() {
    defer func() {
     if err := latch.Return(); err != nil {
      logx.WithContext(r.Context()).Error(err)
     }
    }()

    next.ServeHTTP(w, r)
   } else {
    internal.Errorf(r, "concurrent connections over %d, rejected with code %d",
     n, http.StatusServiceUnavailable)
    w.WriteHeader(http.StatusServiceUnavailable)
   }
  })
 }
}
```

* 实现

```go
// ErrLimitReturn indicates that the more than borrowed elements were returned.
var ErrLimitReturn = errors.New("discarding limited token, resource pool is full, someone returned multiple times")

// Limit controls the concurrent requests.
type Limit struct {
 pool chan lang.PlaceholderType
}

// NewLimit creates a Limit that can borrow n elements from it concurrently.
func NewLimit(n int) Limit {
 return Limit{
  pool: make(chan lang.PlaceholderType, n),
 }
}

// Borrow borrows an element from Limit in blocking mode.
func (l Limit) Borrow() {
 l.pool <- lang.Placeholder
}

// Return returns the borrowed resource, returns error only if returned more than borrowed.
func (l Limit) Return() error {
 select {
 case <-l.pool:
  return nil
 default:
  return ErrLimitReturn
 }
}

// TryBorrow tries to borrow an element from Limit, in non-blocking mode.
// If success, true returned, false for otherwise.
func (l Limit) TryBorrow() bool {
 select {
 case l.pool <- lang.Placeholder:
  return true
 default:
  return false
 }
}
```

### 分析go-zero限流算法

#### 固定窗口限流算法

固定窗口限流算法（Fixed Window Rate Limiting Algorithm）是一种最简单的限流算法，其原理是在固定时间窗口(单位时间)内限制请求的数量。该算法将时间分成固定的窗口，并在每个窗口内限制请求的数量。具体来说，算法将请求按照时间顺序放入时间窗口中，并计算该时间窗口内的请求数量，如果请求数量超出了限制，则拒绝该请求。

* go-zero固定窗口限流器的实现

什么是基于固定窗口计数的限流式，比如一个时间片(假设1s)，最大允许的请求是100，超过这个值，直接报错。

在工程实现上一般要追求容错性和运维方面，一般会把实现放在redis。比如go-zero

go-zero的计算是保存在redis里面的，为了保证原子性，这块的逻辑是lua脚本实现的
<https://mp.weixin.qq.com/s/CTemkZ2aKPCPTuQiDJri0Q>

下面的lua脚本，主要干了2件事

* 通过lua的incrby原子计娄
* 如果第一次访问就加过期时间，主要是为了清空这个窗口
* 返回访问数是否到达限制(1 未到达限制， 2 已达到限制， 0 超出限制)

```lua
local limit = tonumber(ARGV[1])
local window = tonumber(ARGV[2])
local current = redis.call("INCRBY", KEYS[1], 1)
if current == 1 then
    redis.call("expire", KEYS[1], window)
end
if current < limit then
    return 1
elseif current == limit then
    return 2
else
    return 0
end
```

* golang 调用的地方

```go
func (h *PeriodLimit) TakeCtx(ctx context.Context, key string) (int, error) {
 resp, err := h.limitStore.ScriptRunCtx(ctx, periodScript, []string{h.keyPrefix + key}, []string{
  strconv.Itoa(h.quota),
  strconv.Itoa(h.calcExpireSeconds()),
 })
 if err != nil {
  return Unknown, err
 }

 code, ok := resp.(int64)
 if !ok {
  return Unknown, ErrUnknownCode
 }

 switch code {
 case internalOverQuota:
  return OverQuota, nil
 case internalAllowed:
  return Allowed, nil
 case internalHitQuota:
  return HitQuota, nil
 default:
  return Unknown, ErrUnknownCode
 }
}
```

* 基于固定窗口的缺点

假设每个窗口的时间是1s，最大请求数是100, 第一个窗口后0.5s访问了 100, 第二个窗口的前0.5s访问了100，那这段时间实际访问了200，达到限流数的2倍。

### go-zero令牌桶算法

#### 令牌桶算法

令牌桶算法是一种常用的限流算法，可以用于限制单位时间内请求的数量。该算法维护一个固定容量的令牌桶，每秒钟会向令牌桶中放入一定数量的令牌。当有请求到来时，如果令牌桶中有足够的令牌，则请求被允许通过并从令牌桶中消耗一个令牌，否则请求被拒绝。

#### lua脚本

```lua

-- 将输入参数转换为数字，并赋值给相应的变量
local rate = tonumber(ARGV[1]) -- 令牌桶的填充速率
local capacity = tonumber(ARGV[2]) -- 令牌桶的最大容量
local now = tonumber(ARGV[3]) -- 当前时间戳
local requested = tonumber(ARGV[4]) -- 请求的令牌数量

-- 计算填充整个令牌桶所需的时间，并设置过期时间（TTL）为填充时间的两倍
local fill_time = capacity / rate
local ttl = math.floor(fill_time * 2)

-- 从Redis中获取令牌桶当前的令牌数量，如果不存在则默认为桶的容量
local last_tokens = tonumber(redis.call("get", KEYS[1])) -- 从tokens_key获取令牌数量
if last_tokens == nil then
    last_tokens = capacity
end

-- 从Redis中获取令牌桶上次填充的时间戳，如果不存在则默认为0
local last_refreshed = tonumber(redis.call("get", KEYS[2])) -- 从timestamp_key获取时间戳
if last_refreshed == nil then
    last_refreshed = 0
end

-- 计算自上次填充以来经过的时间，并更新令牌桶中的令牌数量
local delta = math.max(0, now - last_refreshed)
local filled_tokens = math.min(capacity, last_tokens + (delta * rate))

-- 判断请求的令牌数量是否小于或等于当前令牌桶中的令牌数量
local allowed = filled_tokens >= requested

-- 更新令牌桶中的令牌数量，如果请求被允许则减去请求的数量
local new_tokens = filled_tokens
if allowed then
    new_tokens = filled_tokens - requested
end

-- 使用setex命令更新令牌桶中的令牌数量和时间戳，并设置过期时间
redis.call("setex", KEYS[1], ttl, new_tokens) -- 更新tokens_key的值和过期时间
redis.call("setex", KEYS[2], ttl, now) -- 更新timestamp_key的值和过期时间

-- 返回是否允许请求，true表示允许，false表示拒绝
return allowed
```
