### 分析go-zero限流算法

* go-zero固定窗口限流器的实现

什么是基于固定窗口计数的限流式，比如一个时间片(假设1s)，最大允许的请求是100，超过这个值，直接报错。

在工程实现上一般要追求容错性和运维方面，一般会把实现放在redis。比如go-zero

go-zero的计算是保存在redis里面的，为了保证原子性，这块的逻辑是lua脚本实现的
<https://mp.weixin.qq.com/s/CTemkZ2aKPCPTuQiDJri0Q>

下面的lua脚本，主要干了2件事

* 通过lua的incrby原子计娄
* 如果第一次访问就加过期时间，主要是为了清空这个窗口
* 返回访问数是否到达限制(1 未到达限制， 2 已达到限制， 0 超出限制)

```lua
local limit = tonumber(ARGV[1])
local window = tonumber(ARGV[2])
local current = redis.call("INCRBY", KEYS[1], 1)
if current == 1 then
    redis.call("expire", KEYS[1], window)
end
if current < limit then
    return 1
elseif current == limit then
    return 2
else
    return 0
end
```

* golang 调用的地方

```go
func (h *PeriodLimit) TakeCtx(ctx context.Context, key string) (int, error) {
 resp, err := h.limitStore.ScriptRunCtx(ctx, periodScript, []string{h.keyPrefix + key}, []string{
  strconv.Itoa(h.quota),
  strconv.Itoa(h.calcExpireSeconds()),
 })
 if err != nil {
  return Unknown, err
 }

 code, ok := resp.(int64)
 if !ok {
  return Unknown, ErrUnknownCode
 }

 switch code {
 case internalOverQuota:
  return OverQuota, nil
 case internalAllowed:
  return Allowed, nil
 case internalHitQuota:
  return HitQuota, nil
 default:
  return Unknown, ErrUnknownCode
 }
}
```

* 基于固定窗口的缺点

假设每个窗口的时间是1s，最大请求数是100, 第一个窗口后0.5s访问了 100, 第二个窗口的前0.5s访问了100，那这段时间实际访问了200，达到限流数的2倍。
