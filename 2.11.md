### go-zero并发控制

默认的并发控制，是基于chan实现的，来的请求向chan写数据，申请资格，离开的时候从chan读数据

* 配置文件

```yaml
MaxConns: 100
```

* 加载的中间件

```go
func MaxConnsHandler(n int) func(http.Handler) http.Handler {
 if n <= 0 {
  return func(next http.Handler) http.Handler {
   return next
  }
 }

 return func(next http.Handler) http.Handler {
  latch := syncx.NewLimit(n)

  return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
   if latch.TryBorrow() {
    defer func() {
     if err := latch.Return(); err != nil {
      logx.WithContext(r.Context()).Error(err)
     }
    }()

    next.ServeHTTP(w, r)
   } else {
    internal.Errorf(r, "concurrent connections over %d, rejected with code %d",
     n, http.StatusServiceUnavailable)
    w.WriteHeader(http.StatusServiceUnavailable)
   }
  })
 }
}
```

* 实现

```go
// ErrLimitReturn indicates that the more than borrowed elements were returned.
var ErrLimitReturn = errors.New("discarding limited token, resource pool is full, someone returned multiple times")

// Limit controls the concurrent requests.
type Limit struct {
 pool chan lang.PlaceholderType
}

// NewLimit creates a Limit that can borrow n elements from it concurrently.
func NewLimit(n int) Limit {
 return Limit{
  pool: make(chan lang.PlaceholderType, n),
 }
}

// Borrow borrows an element from Limit in blocking mode.
func (l Limit) Borrow() {
 l.pool <- lang.Placeholder
}

// Return returns the borrowed resource, returns error only if returned more than borrowed.
func (l Limit) Return() error {
 select {
 case <-l.pool:
  return nil
 default:
  return ErrLimitReturn
 }
}

// TryBorrow tries to borrow an element from Limit, in non-blocking mode.
// If success, true returned, false for otherwise.
func (l Limit) TryBorrow() bool {
 select {
 case l.pool <- lang.Placeholder:
  return true
 default:
  return false
 }
}
```
