1、HTTP里有哪些常见的请求方法？
GET/POST/PUT/DELETE/PATCH

**GET**
* 用途：请求指定资源的表示形式。通常用于请求数据，而不会修改服务器上的资源。
* 特点：
请求参数通常在URL中传递。
是幂等的，即多次请求对资源没有副作用。
不应该用于包含敏感数据的请求，因为它会被记录在浏览历史中。

**POST**
* 用途：向指定资源提交数据进行处理（例如提交表单或上传文件）。数据包含在请求体中。
* 特点：
通常用于创建资源。
不是幂等的，即多次请求可能会导致多个资源被创建。
可以处理大量数据，适合发送表单数据、文件等。

**PUT**
* 用途：向指定资源位置上传表示形式。通常用于更新资源的全部内容。
* 特点：
是幂等的，即多次请求对资源的影响是相同的。
如果资源不存在，通常会创建新资源。

**DELETE**
* 用途：删除指定资源。
* 特点：
是幂等的，即多次请求删除同一资源的结果是相同的（资源被删除）。
通常返回204 No Content状态码，表示请求成功但无返回内容。

**HEAD**
* 用途：与GET方法一样请求资源，但不返回资源主体部分。
* 特点：
用于获取元数据（例如头信息），而不获取资源内容。
常用于检查资源是否存在，或者获取资源的大小、类型等信息。

**OPTIONS**
* 用途：请求指定资源支持的HTTP方法。
* 特点：
返回的响应头包含Allow头部，指明支持的HTTP方法。
常用于跨域资源共享（CORS）预检请求，检查服务器是否允许跨域请求。



2、HTTP的长连接和短连接有什么区别？

HTTP 1.1/2/3默认是长连接, 对于1.1需要显示设置 `Connection: keep-alive`
HTTP 1.0默认是短连接

3、长连接与短连接的操作过程是什么？

4、长连接与短连接的使用时机

5、HTTP的状态码，504有遇到过吗？

HTTP 状态码 504 Gateway Timeout 是服务器在作为网关或代理时，无法在规定的时间内从上游服务器（如 HTTP、HTTPS、FTP）接收到响应时返回的错误。这个状态码表明网关或代理无法获得所需的响应。

6、GET和POST的区别？
对于通信实现的角度区别只是GET和POST两个字符串的区别。
对于业务开发来说，GET代码获取。POST代表创建

7、什么是无状态协议，HTTP是无状态协议吗，怎么解决？

* 无状态协议（Stateless Protocol）是一种通信协议，在这种协议中，每个请求都是独立的，并且与之前的请求没有关联。服务器不会保存客户端的状态，每次请求都必须包含所有必要的信息，以便服务器能够理解和处理请求
* HTTP是一种无状态协议。这意味着每个 HTTP 请求都是独立的，服务器不会保留任何关于之前请求的信息。每次请求和响应之间没有任何上下文关联。
* 解决
  * Cookies（由服务器发送到客户端并由客户端存储的一小段数据）
  * Sessions（一种在服务器端存储用户状态的机制。通常，Session 结合 Cookies 使用。服务器生成一个唯一的 Session ID，并将其发送给客户端，客户端将这个 ID 存储在 Cookie 中，并在后续请求中发送给服务器。）
  * JWT（JWT 通过在客户端和服务器之间传递自包含的令牌，可以有效解决 HTTP 的无状态问题，实现身份验证和会话管理。使用 JWT，服务器无需存储任何会话信息，使得应用更加简洁和可扩展。）
    * 在用户登录成功后，生成一个包含用户信息和过期时间的 JWT。
    * 客户端将生成的 JWT 存储起来，并在后续请求中将其添加到 Authorization 头中发送给服务器。
    * 服务器在每个请求中验证 JWT 的签名和解析其负载部分来确认用户身份。

8、HTTP请求的组成？
* 请求行（Request Line）：包含 HTTP 方法、请求目标 URI 和 HTTP 版本
  ```go
  GET /api/v1/users HTTP/1.1
  ```
* 请求头（Headers）：提供请求的元数据信息，包含键值对形式的头字段
  ```go
  Host: example.com
  User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36
  Accept: application/json
  ```
* 空行：用于分隔请求头和请求体
* 请求体（Body）（可选）：包含发送给服务器的数据，仅在需要时使用，如 POST 请求
  ```go
  { "username": "testuser", "password": "password123" }
  ```
9、HTTP响应的组成？
* 状态行：包含 HTTP 版本、状态码和状态描述
  ```go
  HTTP/1.1 200 OK
  ```
* 响应头：提供关于响应的元数据，以键值对的形式存在
  ```go
  Content-Type: application/json
  Content-Length: 85
  ```
* 空行：用于分隔响应头和响应体。
* 响应体：包含实际的响应数据，可以是各种格式，如 HTML、JSON 等
  ```go
  {
  "users": [
    {"id": 1, "name": "John Doe"},
    {"id": 2, "name": "Jane Smith"}
  ]
  }
  ```
10、Cookies机制和Session机制的区别？

* Cookies 和 Session 都是用来在客户端和服务器之间管理状态信息的机制。
* 主要区别在于存储位置和安全性。Cookies 存储在客户端，通常用于存储少量的标识信息，比如用户登录状态。而 Session 数据存储在服务器端，可以存储任意类型的数据，如用户登录信息、购物车内容等。
* Session 更安全，因为数据存储在服务器端，而 Cookies 可能会被篡改。选择使用哪种取决于需求，如果需要存储大量或敏感数据，通常会选择 Session。

11、RPC和HTTP的区别？

* 用途
  * RPC 是用于不同进程或不同机器间进行函数调用的机制，允许一个程序调用另一个程序的过程（函数）而不需要了解底层网络细节。
  * HTTP 是用于客户端和服务器之间传输超文本文档的协议，主要用于浏览器和 Web 服务器之间的通信，支持传输各种类型的数据和资源。
* 通信模型
  * RPC 通常基于请求-响应模型，请求方向目标发起请求，并等待响应结果。RPC 可以使用不同的传输协议，如 TCP、UDP 或 HTTP
  * HTTP 是一个无状态的协议，每个请求和响应之间是独立的，通常使用请求-响应模型，但可以通过持久连接（HTTP Keep-Alive）来提高效率。
* 数据格式
  * RPC 通常使用更轻量级的数据格式，如 Protocol Buffers 或 JSON，以便于在网络上传输。
  * HTTP 使用文本格式的协议，请求和响应使用 HTTP 头和正文来传输数据，支持各种媒体类型和编码方式。
* 应用场景
  * RPC 更适用于需要高效的远程过程调用，如微服务架构中服务之间的通信。
  * HTTP 更适用于 Web 应用程序、API 接口的实现和通信，以及浏览器和服务器之间的数据交换。

12、HTTP的握手是什么样的？

 * HTTP 协议本身并没有所谓的握手过程，但 HTTP/1.1 通常运行在 TCP 协议之上，而 TCP 有一个握手过程来建立连接。
 * 第一次握手：客户端发送一个 SYN 包给服务器，表示希望建立连接。
 * 第二次握手：服务器收到 SYN 包后，发送一个 SYN-ACK 包给客户端，表示同意建立连接。
 * 第三次握手：客户端收到 SYN-ACK 包后，发送一个 ACK 包给服务器，确认连接建立。

13、Websocket协议和HTTP的关系是什么？

websocket使用了http作为握手协议, 握手成功之后就是tcp通信

14、HTTP和HTTPS的区别？

* HTTP是用于客户端和服务端之间的超文本传输协议，默认端口80。HTTPS在HTTP基础上SSL/TLS 加密层的协议，默认使用端口443。
* HTTP明文传输，不安全，HTTPS使用SSL/TLS 加密，更安全
* HTTP不用认证，无法保证双方身份，HTTPS客户端使用证书验证服务器合法性

15、HTTPS实现原理？

1. 客户端向服务器发送 HTTPS 请求。
2. 服务器返回包含公钥的数字证书。
3. 客户端验证数字证书的有效性。
4. 客户端生成随机会话密钥，并使用公钥加密，发送给服务器。
5. 服务器使用私钥解密获取会话密钥。（私钥是服务端和公钥一起生成，为了解客户端使用公钥加密的会话秘钥）
6. 客户端和服务器使用对称会话密钥进行加密通信。

16、CA的数字证书中包括哪些信息？

* 版本（Version）：证书的版本号，指示证书结构的版本。
* 序列号（Serial Number）：由 CA 分配的唯一标识符，用于标识证书。
* 签名算法（Signature Algorithm）：用于签署证书的算法，例如 SHA256-RSA。
* 颁发者（Issuer）：颁发证书的 CA 的信息，包括 CA 的名称和其他识别信息。
* 有效期（Validity Period）：证书的有效时间段，包括起始日期（Not Before）和截止日期（Not After）。
* 主体（Subject）：证书持有者的信息，包括持有者的名称、组织、部门、城市、州和国家等。
* 主体公钥信息（Subject Public Key Info）：持有者的公钥及其使用的算法。
* 扩展信息（Extensions）：附加的扩展信息
* 签名（Signature）：由 CA 使用其私钥对证书内容进行的数字签名，用于验证证书的完整性和真实性。

17、SSL建立连接过程？

* 客户端发起连接请求：客户端向服务器发送 SSL 版本号、支持的加密算法列表和随机数（ClientHello 消息）。
* 服务器响应：服务器回复包含 SSL 版本号、选择的加密算法、服务器证书（包含公钥）和另一个随机数的消息（ServerHello 消息）。
* 验证服务器证书：客户端验证服务器证书的合法性，确保其由可信的证书颁发机构签发，并在有效期内。
* 生成会话密钥：客户端生成一个随机的会话密钥（Pre-Master Secret），使用服务器的公钥加密，并发送给服务器。
* 使用服务器私钥解密：服务器使用自己的私钥解密客户端发送的 Pre-Master Secret，从而获取会话密钥。
* 协商加密参数：双方根据协商好的加密算法和会话密钥，确定最终的加密套件和参数。
* 加密通信：双方使用协商好的会话密钥进行对称加密通信，保护数据的隐私性和完整性。
* 完成握手：SSL 握手成功完成，双方可以安全地开始数据传输。

18、HTTPS的加密协议是什么？

TLS 是一种用于在计算机网络上进行安全通信的加密协议

19、HTTPS怎么保证服务器给客户端下发的公钥是真正的公钥，而不是中间人伪造的公钥呢？

* 数字证书：服务器的公钥包含在由受信任的证书颁发机构（CA）签发的数字证书中。
* 证书链验证：客户端会验证服务器提供的证书是否由受信任的 CA 签发。客户端有一个预安装的根证书存储，用于验证服务器证书的签名。
* 证书的签名：服务器证书由 CA 使用其私钥进行签名。客户端使用 CA 的公钥验证签名的合法性，确保证书未被篡改。
* 域名验证：客户端检查证书中的域名是否与服务器的域名匹配，确保连接的是预期的服务器。

20、第三方攻击者能否让自己的证书显示出来的信息也是服务端呢？

21、HTTPS优缺点

* HTTPS的优点：
  * 数据加密：HTTPS 使用 TLS/SSL 协议加密数据，确保数据在传输过程中不被窃听和篡改，保护用户隐私。
  * 身份验证：HTTPS 通过数字证书验证服务器的身份，防止中间人攻击，确保用户连接的是合法网站。
  * 数据完整性：HTTPS 确保数据在传输过程中未被篡改，通过消息认证码（MAC）验证数据的完整性。
  * 用户信任：浏览器会显示 HTTPS 连接的安全锁图标，提高用户对网站的信任度，特别是对于电子商务网站和金融服务网站。
  * SEO 优势：搜索引擎（如 Google）对使用 HTTPS 的网站给予更高的排名优先级，提升网站的搜索引擎优化（SEO）效果。

* HTTPS的缺点：
  * 性能开销：HTTPS 的加密和解密过程会增加服务器和客户端的计算负担，可能导致较高的 CPU 和内存使用，影响响应时间。
  * 证书成本：获取和维护数字证书需要费用，尤其是从知名的 CA 购买证书可能会产生较高的成本。不过，免费的证书颁发机构（如 Let’s Encrypt）已经大大降低了这一门槛。
  * 复杂性增加：HTTPS 需要正确配置服务器、证书和相关设置，对于小型网站或没有专门技术团队的组织，可能会增加实现难度。
  * 证书管理：证书有有效期，需定期更新和管理，过期或配置错误的证书可能导致网站不可访问或被标记为不安全。
  * 兼容性问题：某些旧版浏览器或操作系统可能不完全支持最新的 TLS 协议或某些加密算法，可能导致兼容性问题。

22、HTTPS的证书是谁验证谁？

23、HTTPS单向认证时谁验证谁？

24、HTTPS客户端如何验证服务端证书的合法性？

25、HTTPS信息摘要的算法是什么？

26、HTTPS交换的是什么？

27、HTTPS数据传输用什么加密方式？

28、HTTP2相比HTTP1有什么优势？

* 首先，HTTP/2 支持多路复用，可以在一个连接上同时发送多个请求和响应，避免了队头阻塞问题；
* 其次，HTTP/2 采用头部压缩技术，减少了重复头部信息的传输，提升了传输效率；
* 此外，HTTP/2 支持服务器推送，服务器可以主动将资源推送到客户端，减少等待时间；
* 最后，HTTP/2 使用二进制格式传输数据，相比文本格式解析更高效，更加稳定。
* 总体来说，HTTP/2 提升了数据传输的效率和速度，优化了用户体验

29、GRPC是HTTP2还是HTTP1？

* gRPC 是基于 HTTP/2 的。HTTP/2 提供了双向流、多路复用、头部压缩和服务器推送等特性，这些特性使得 gRPC 在性能和效率上得到了很大的提升
  * 双向流：允许客户端和服务器在同一连接上同时发送和接收多个消息流
  * 多路复用：HTTP/2 允许在一个 TCP 连接上并发发送多个请求和响应，消除了 HTTP/1.x 中的队头阻塞问题
  * 头部压缩：HTTP/2 使用 HPACK 头部压缩算法，减少了传输的开销，提高了性能

30、TCP和HTTP的区别？

HTTP 1.1是在TCP上面运行，封装了请求行，请求头， 请求体，响应行，响应头，响应体

31、HTTP是在TCP之上运行，两者的包会有什么区别？

* HTTP 是应用层协议，用于客户端和服务器之间的数据交换，包括请求和响应的具体内容。
* TCP 是传输层协议，负责在网络中传输数据并确保可靠传输。
* HTTP 包作为数据负载被封装在 TCP 包中，TCP 包则包含源端口、目标端口、序列号等信息，以确保数据可靠传输

32、TCP特点

33、TCP使用场景

34、基于（使用）TCP的协议有哪些？

35、TCP三次握手

36、TCP在握手完成之后，A到B发送数据，中间有个数据被篡改，它会怎处理？

37、TCP三次握手的两种队列

38、TCP如何实现可靠性传输？

39、TCP建立连接的时候为什么是三次握手，不是两次或四次？

40、TCP四次挥手

41、TCP前面加个防火墙，那TCP的包会在哪一步被拦截掉？

42、TCP一个端口可以并发接收多少请求？

43、TCP可能有几万个、几十万个、上百万个链接都在这个端口上，怎么知道它是哪个链接，对应哪个用户，对应哪个请求？

44、Tcp粘包拆包是怎么发生的？该怎么解决？就是接到数据以后怎么解决呢？

45、跨域是怎么完成的？

**请求时设置CORS响应头**

```go
package main

import (
	"fmt"
	"net/http"
)

// 处理跨域请求的中间件
func cors(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// 设置CORS响应头
		w.Header().Set("Access-Control-Allow-Origin", "*")
		w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
		w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")

		// 处理预检请求（OPTIONS）
		if r.Method == http.MethodOptions {
			w.WriteHeader(http.StatusOK)
			return
		}

		// 调用下一个处理器
		next.ServeHTTP(w, r)
	})
}

// 示例处理器
func helloHandler(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintln(w, "Hello, World!")
}

func main() {
	mux := http.NewServeMux()

	// 将处理器注册到多路复用器
	mux.Handle("/", cors(http.HandlerFunc(helloHandler)))

	// 启动服务器
	http.ListenAndServe(":8080", mux)
}

```

**使用第三方库github.com/rs/cors**

```go
package main

import (
	"fmt"
	"net/http"

	"github.com/rs/cors"
)

func helloHandler(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintln(w, "Hello, World!")
}

func main() {
	mux := http.NewServeMux()
	mux.HandleFunc("/", helloHandler)

	// 使用第三方库处理CORS
	handler := cors.Default().Handler(mux)

	http.ListenAndServe(":8080", handler)
}

```

**配置自定义CORS选项**

```go
func main() {
	mux := http.NewServeMux()
	mux.HandleFunc("/", helloHandler)

	// 配置自定义CORS选项
	c := cors.New(cors.Options{
		AllowedOrigins:   []string{"http://example.com"}, // 允许的来源
		AllowedMethods:   []string{"GET", "POST", "PUT", "DELETE"}, // 允许的HTTP方法
		AllowedHeaders:   []string{"Content-Type", "Authorization"}, // 允许的HTTP头
		ExposedHeaders:   []string{"Content-Length"}, // 暴露的头
		AllowCredentials: true, // 是否允许凭证
	})

	// 使用自定义CORS配置
	handler := c.Handler(mux)

	http.ListenAndServe(":8080", handler)
}

```

