1、HTTP里有哪些常见的请求方法？
GET/POST/PUT/DELETE/PATCH

**GET**
* 用途：请求指定资源的表示形式。通常用于请求数据，而不会修改服务器上的资源。
* 特点：
请求参数通常在URL中传递。
是幂等的，即多次请求对资源没有副作用。
不应该用于包含敏感数据的请求，因为它会被记录在浏览历史中。

**POST**
* 用途：向指定资源提交数据进行处理（例如提交表单或上传文件）。数据包含在请求体中。
* 特点：
通常用于创建资源。
不是幂等的，即多次请求可能会导致多个资源被创建。
可以处理大量数据，适合发送表单数据、文件等。

**PUT**
* 用途：向指定资源位置上传表示形式。通常用于更新资源的全部内容。
* 特点：
是幂等的，即多次请求对资源的影响是相同的。
如果资源不存在，通常会创建新资源。

**DELETE**
* 用途：删除指定资源。
* 特点：
是幂等的，即多次请求删除同一资源的结果是相同的（资源被删除）。
通常返回204 No Content状态码，表示请求成功但无返回内容。

**HEAD**
* 用途：与GET方法一样请求资源，但不返回资源主体部分。
* 特点：
用于获取元数据（例如头信息），而不获取资源内容。
常用于检查资源是否存在，或者获取资源的大小、类型等信息。

**OPTIONS**
* 用途：请求指定资源支持的HTTP方法。
* 特点：
返回的响应头包含Allow头部，指明支持的HTTP方法。
常用于跨域资源共享（CORS）预检请求，检查服务器是否允许跨域请求。



2、HTTP的长连接和短连接有什么区别？
HTTP 1.1/2/3默认是长连接, 对于1.1需要显示设置 `Connection: keep-alive`
HTTP 1.0默认是短连接

3、长连接与短连接的操作过程是什么？

4、长连接与短连接的使用时机

5、HTTP的状态码，504有遇到过吗？

HTTP 状态码 504 Gateway Timeout 是服务器在作为网关或代理时，无法在规定的时间内从上游服务器（如 HTTP、HTTPS、FTP）接收到响应时返回的错误。这个状态码表明网关或代理无法获得所需的响应。

6、GET和POST的区别？
对于通信实现的角度区别只是GET和POST两个字符串的区别。
对于业务开发来说，GET代码获取。POST代表创建

7、什么是无状态协议，HTTP是无状态协议吗，怎么解决？

* 无状态协议（Stateless Protocol）是一种通信协议，在这种协议中，每个请求都是独立的，并且与之前的请求没有关联。服务器不会保存客户端的状态，每次请求都必须包含所有必要的信息，以便服务器能够理解和处理请求
* HTTP是一种无状态协议。这意味着每个 HTTP 请求都是独立的，服务器不会保留任何关于之前请求的信息。每次请求和响应之间没有任何上下文关联。
* 解决
  * Cookies（由服务器发送到客户端并由客户端存储的一小段数据）
  * Sessions（一种在服务器端存储用户状态的机制。通常，Session 结合 Cookies 使用。服务器生成一个唯一的 Session ID，并将其发送给客户端，客户端将这个 ID 存储在 Cookie 中，并在后续请求中发送给服务器。）
  * JWT（JWT 通过在客户端和服务器之间传递自包含的令牌，可以有效解决 HTTP 的无状态问题，实现身份验证和会话管理。使用 JWT，服务器无需存储任何会话信息，使得应用更加简洁和可扩展。）
    * 在用户登录成功后，生成一个包含用户信息和过期时间的 JWT。
    * 客户端将生成的 JWT 存储起来，并在后续请求中将其添加到 Authorization 头中发送给服务器。
    * 服务器在每个请求中验证 JWT 的签名和解析其负载部分来确认用户身份。

8、HTTP请求的组成？
* 请求行（Request Line）：包含 HTTP 方法、请求目标 URI 和 HTTP 版本
  ```go
  GET /api/v1/users HTTP/1.1
  ```
* 请求头（Headers）：
* 空行：
* 请求体（Body）（可选）：

9、HTTP响应的组成？

10、Cookies机制和Session机制的区别？

* Cookies 和 Session 都是用来在客户端和服务器之间管理状态信息的机制。
* 主要区别在于存储位置和安全性。Cookies 存储在客户端，通常用于存储少量的标识信息，比如用户登录状态。而 Session 数据存储在服务器端，可以存储任意类型的数据，如用户登录信息、购物车内容等。
* Session 更安全，因为数据存储在服务器端，而 Cookies 可能会被篡改。选择使用哪种取决于需求，如果需要存储大量或敏感数据，通常会选择 Session。

11、RPC和HTTP的区别？

* 用途
  * RPC 是用于不同进程或不同机器间进行函数调用的机制，允许一个程序调用另一个程序的过程（函数）而不需要了解底层网络细节。
  * HTTP 是用于客户端和服务器之间传输超文本文档的协议，主要用于浏览器和 Web 服务器之间的通信，支持传输各种类型的数据和资源。
* 通信模型
  * RPC 通常基于请求-响应模型，请求方向目标发起请求，并等待响应结果。RPC 可以使用不同的传输协议，如 TCP、UDP 或 HTTP
  * HTTP 是一个无状态的协议，每个请求和响应之间是独立的，通常使用请求-响应模型，但可以通过持久连接（HTTP Keep-Alive）来提高效率。
* 数据格式
  * RPC 通常使用更轻量级的数据格式，如 Protocol Buffers 或 JSON，以便于在网络上传输。
  * HTTP 使用文本格式的协议，请求和响应使用 HTTP 头和正文来传输数据，支持各种媒体类型和编码方式。
* 应用场景
  * RPC 更适用于需要高效的远程过程调用，如微服务架构中服务之间的通信。
  * HTTP 更适用于 Web 应用程序、API 接口的实现和通信，以及浏览器和服务器之间的数据交换。

12、HTTP的握手是什么样的？

13、Websocket协议和HTTP的关系是什么？
websocket使用了http作为握手协议, 握手成功之后就是tcp通信

14、HTTP和HTTPS的区别？

15、HTTPS实现原理？

16、CA的数字证书中包括哪些信息？

17、SSL建立连接过程？

18、HTTPS的加密协议是什么？

19、HTTPS怎么保证服务器给客户端下发的公钥是真正的公钥，而不是中间人伪造的公钥呢？

20、第三方攻击者能否让自己的证书显示出来的信息也是服务端呢？

21、HTTPS优缺点

22、HTTPS的证书是谁验证谁？

23、HTTPS单向认证时谁验证谁？

24、HTTPS客户端如何验证服务端证书的合法性？

25、HTTPS信息摘要的算法是什么？

26、HTTPS交换的是什么？

27、HTTPS数据传输用什么加密方式？

28、HTTP2相比HTTP1有什么优势？

29、GRPC是HTTP2还是HTTP1？

30、TCP和HTTP的区别？
HTTP 1.1是在TCP上面运行，封装了请求行，请求头， 请求体，响应行，响应头，响应体

31、HTTP是在TCP之上运行，两者的包会有什么区别？

32、TCP特点

33、TCP使用场景

34、基于（使用）TCP的协议有哪些？

35、TCP三次握手

36、TCP在握手完成之后，A到B发送数据，中间有个数据被篡改，它会怎处理？

37、TCP三次握手的两种队列

38、TCP如何实现可靠性传输？

39、TCP建立连接的时候为什么是三次握手，不是两次或四次？

40、TCP四次挥手

41、TCP前面加个防火墙，那TCP的包会在哪一步被拦截掉？

42、TCP一个端口可以并发接收多少请求？

43、TCP可能有几万个、几十万个、上百万个链接都在这个端口上，怎么知道它是哪个链接，对应哪个用户，对应哪个请求？

44、Tcp粘包拆包是怎么发生的？该怎么解决？就是接到数据以后怎么解决呢？

45、跨域是怎么完成的？

**请求时设置CORS响应头**

```go
package main

import (
	"fmt"
	"net/http"
)

// 处理跨域请求的中间件
func cors(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// 设置CORS响应头
		w.Header().Set("Access-Control-Allow-Origin", "*")
		w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
		w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")

		// 处理预检请求（OPTIONS）
		if r.Method == http.MethodOptions {
			w.WriteHeader(http.StatusOK)
			return
		}

		// 调用下一个处理器
		next.ServeHTTP(w, r)
	})
}

// 示例处理器
func helloHandler(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintln(w, "Hello, World!")
}

func main() {
	mux := http.NewServeMux()

	// 将处理器注册到多路复用器
	mux.Handle("/", cors(http.HandlerFunc(helloHandler)))

	// 启动服务器
	http.ListenAndServe(":8080", mux)
}

```

**使用第三方库github.com/rs/cors**

```go
package main

import (
	"fmt"
	"net/http"

	"github.com/rs/cors"
)

func helloHandler(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintln(w, "Hello, World!")
}

func main() {
	mux := http.NewServeMux()
	mux.HandleFunc("/", helloHandler)

	// 使用第三方库处理CORS
	handler := cors.Default().Handler(mux)

	http.ListenAndServe(":8080", handler)
}

```

**配置自定义CORS选项**

```go
func main() {
	mux := http.NewServeMux()
	mux.HandleFunc("/", helloHandler)

	// 配置自定义CORS选项
	c := cors.New(cors.Options{
		AllowedOrigins:   []string{"http://example.com"}, // 允许的来源
		AllowedMethods:   []string{"GET", "POST", "PUT", "DELETE"}, // 允许的HTTP方法
		AllowedHeaders:   []string{"Content-Type", "Authorization"}, // 允许的HTTP头
		ExposedHeaders:   []string{"Content-Length"}, // 暴露的头
		AllowCredentials: true, // 是否允许凭证
	})

	// 使用自定义CORS配置
	handler := c.Handler(mux)

	http.ListenAndServe(":8080", handler)
}

```

